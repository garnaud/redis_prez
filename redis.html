<!DOCTYPE html>
<html>
  <head>
    <title>Service Discovery</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      img {  max-width: 100%;  }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Le Service Discovery

---

# Agenda

TODO

---

# Le service discovery d’après wikipédia

Service discovery protocols (SDP) are network protocols that allow automatic detection of devices and services offered by these devices on a computer network. 
Service discovery requires a common language to allow software agents to make use of one another's services without the need for continuous user intervention


---

# Dans le cadre d’un SI

* Lors de son démarrage, chaque services doit s’enregistrer dans un annuaire en fournissant les informations utiles pour y accéder.

* On ne connaît plus l’emplacement(ip / port / url path / protocols ...) des services que l’on consommes.

* On utilise le nom d’un service afin qu’on nous fournissent dynamiquement la manière d’y accéder

---

# Intérêt du ServiceDiscovery ?

* Les architecture cloud, l’autoscaling et maintenant les conteneurs rendent impossible la configuration manuelle de l’emplacement des services.

* Les services doivent pouvoir trouver leurs dépendances de manière dynamique.
 
---

# Théorie

Basiquement, le service discovery se décompose en trois parti :

* L’annuaire de service, qui stocke les données des services.

* La mise a jour des données services (enregistrement d’un service, suppression).

* La recherche de l’adresse des services dans l’annuaire.

---

# Théorie : pattern d’enregistrement

 * Self registration : 

    Le client est responsable de venir s’enregistrer dans l’annuaire de service et de maintenir à jour ses informations.

    Avantages:

    + Possibilité d’avoir une gestion plus complex que UP/DOWN de l’état du service

    Inconveniants:

	- Couplage du service avec l’annuaire

	- Réimplémentation dans toutes les langages des services du SI

---

# Théorie : pattern d’enregistrement

 * Thrid party registration :

    Un logiciel tier est responsable d’enregistrer les nouveaux services

    Avantages:

    + Code du service moins complexe

    + Gestion des healthcheck simplifié

    Inconveniants:

    - Un composant de plus a maintenir et redonder

---

# Théorie : pattern de recherche

 * Client-side service discovery

    Le client est responsable d’interroger l’annuaire pour connaître l’emplacement des services qu’il vut appeler.

    Avantages:

    + Moins d’aller retour réseau

    Inconveniants:

    - Couplage du service avec l’annuaire

    - Réimplémentation dans toutes les langages des services du SI

---

# Théorie : pattern de recherche

 * Server-side service discovery

    Le client interroge un serveur tiers bien connu qui fera le service discovery pour lui.

    Avantages:

    + Code du service moins complexe

    Inconveniants:

    - Un composant de plus a maintenir et redonder

---

# A prendre en compte

 * L’annuaire de services devient un Single point of failure du SI.

 * Chaque service doit être monitoré et supprimé de l’annuaire si il n’est plus disponible.

 * Coût réseau du au requête de service discovery non négligeable.

 * Integration des services externes dans l'annuaire

---

# État des lieux VSCT

 * Le loadbalancing des services et le healthcheck est géré par des HAProxy

 * On accèdent au HAProxy de manière static avec une ip(ou un dns) et un port.

 * HAProxy va également faire du routing de requête en fonction de l’url (ou autre critère)

---

# État des lieux VSCT : Strowgr

 * Strowgr est une nouvelle brique du SI VSCT qui permet d’ajouter automatiquement des services en tant que backend dans un HAProxy

 * Ce n’est donc pas du Service discovery car il n’y a aucun moyen de connaître le HAProxy cible pour un service tiers

---

# Le besoin

 * Une solution de service discovery complète

 * Pas de nouveau Spof

 * Intégration avec l’existant

---

# Solution proposée

 * Annuaire de Service Discovery a base de Consul:

  - Key/Value Store équivalent a zookeeper et Etcd

  - Service discovery natif

  - Nativement multidatacenter

  - Déjà présent chez VSCT (Dans la solution Strowger)

 * Enregistrement à base de Strowger:

    Les nouvelles briques du SI a venir doivent snregistrer dans le HAP via Strawgr. Il faut en profiter pour les enregistrer également dans l'annuaire de services.

    - Utilise déjà consul

    - Compatible avec toutes autres solutions

---

# Solution proposée

 * Recherche standard a base de consul et consul agent, customisable en fonction de la vetusté de l'application

  - Processus externe pour le legacy : pas besoin de toucher au code des services existant

  - Lib internes pour les nouveaux services


---

# Solution proposée

![Alt text](/home/groupevsc.com/yannick_lorenzati/w/experimental/servicediscovery/archi.svg)


---

# Sources
 
* http://microservices.io/
* https://www.consul.io

---

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
